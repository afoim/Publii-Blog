{
    "version": "https://jsonfeed.org/version/1",
    "title": "AcoFork AI Blog ❤",
    "description": "",
    "home_page_url": "https://ai.onani.cn",
    "feed_url": "https://ai.onani.cn/feed.json",
    "user_comment": "",
    "author": {
        "name": "AcoFork"
    },
    "items": [
        {
            "id": "https://ai.onani.cn/blog-saveimg.html",
            "url": "https://ai.onani.cn/blog-saveimg.html",
            "title": "静态博客存图的多种方式以及利弊",
            "summary": "1. 不做管理，直接将图片存入Git仓库&hellip;",
            "content_html": "<h3>1. 不做管理，直接将图片存入Git仓库</h3>\n<p>如果你是使用GIthub进行版本管理，然后使用静态构建服务提供商（如Cloudflare Page、Vercel）来构建你的博客，则这种方法是0配置的，开箱即用的。</p>\n<p>直接使用MarkDown语法链接图片的相对路径，然后在推送更改时将图片一并推送到Github，当你使用静态构建服务提供商进行构建时，图片就会被缓存到你的静态构建服务提供商的CDN。推荐Vercel，因为相较于Cloudflare Page快了不少</p>\n<p>例子1：本博客：<a href=\"https://ai.onani.cn\" target=\"_blank\" rel=\"noopener noreferrer\">https://ai.onani.cn</a></p>\n<p>例子2：通过Vercel存储的图片：<a href=\"https://ai.onani.cn/media/posts/16/responsive/Snipaste_2025-02-18_06-32-46-2xl.webp\" target=\"_blank\" rel=\"noopener noreferrer\">https://ai.onani.cn/media/posts/16/responsive/Snipaste_2025-02-18_06-32-46-2xl.webp</a></p>\n<h3>2. Cloudflare R2</h3>\n<p>Cloudflare R2是一个对象存储服务，零下行费用，免费存储10G，对于博客存图来说肯定是够够的了</p>\n<p>使用这种方法需要有一定的技术，你首先需要寻找你的博客框架是否有插件帮你接入对象存储，如果有，你需要学习如何使用它，又或者你认为插件支持不好，就需要手动去制作一个帮你上传到对象存储的中间件，我这里放出我自用的自动生成MarkDown图片链接的插件（默认支持Cloudflare R2），Python脚本，适用于Windows：</p>\n<pre class=\"language-python line-numbers\"><code>import keyboard\nimport pyperclip\nfrom PIL import ImageGrab, Image\nimport io\nimport boto3\nfrom botocore.config import Config\nimport time\nimport uuid\nimport pyautogui\nimport os\nfrom io import BytesIO\n# 示例配置\n# # R2 配置\n# R2_CONFIG = {\n#     'account_id': '11111111111111111',\n#     'access_key_id': '11111111111111111',\n#     'secret_access_key': '11111111111111111',\n#     'bucket_name': '11111111111111111'\n# }\n\n# # OSS 配置\n# OSS_CONFIG = {\n#     'url': 'oss.onani.cn',\n#     'prefix': '/fuwari-blog/img'\n# }\n#########################################################\n# R2 配置\nR2_CONFIG = {\n    'account_id': '',\n    'access_key_id': '',\n    'secret_access_key': '',\n    'bucket_name': ''\n}\n\n# OSS 配置\nOSS_CONFIG = {\n    'url': '',\n    'prefix': ''\n}\n#########################################################\ndef init_r2_client():\n    \"\"\"初始化 R2 客户端\"\"\"\n    return boto3.client(\n        's3',\n        endpoint_url=f'https://{R2_CONFIG[\"account_id\"]}.r2.cloudflarestorage.com',\n        aws_access_key_id=R2_CONFIG['access_key_id'],\n        aws_secret_access_key=R2_CONFIG['secret_access_key'],\n        config=Config(signature_version='s3v4'),\n        region_name='auto'\n    )\n\ndef get_image_from_clipboard():\n    \"\"\"从剪贴板获取图片\"\"\"\n    try:\n        image = ImageGrab.grabclipboard()\n        if image is None:\n            return None\n            \n        # 如果是列表（多个文件），取第一个\n        if isinstance(image, list):\n            if len(image) &gt; 0:\n                # 如果是图片文件路径，打开它\n                try:\n                    return Image.open(image[0])\n                except Exception as e:\n                    print(f\"打开图片文件失败: {e}\")\n                    return None\n            return None\n            \n        # 如果直接是 Image 对象\n        if isinstance(image, Image.Image):\n            return image\n            \n        return None\n    except Exception as e:\n        print(f\"获取剪贴板图片失败: {e}\")\n        return None\n\ndef convert_to_webp(image):\n    \"\"\"将图片转换为 webp 格式\"\"\"\n    if not image:\n        return None\n    \n    try:\n        buffer = BytesIO()\n        # 确保图片是 RGB 模式\n        if image.mode in ('RGBA', 'LA'):\n            background = Image.new('RGB', image.size, (255, 255, 255))\n            background.paste(image, mask=image.split()[-1])\n            image = background\n        elif image.mode != 'RGB':\n            image = image.convert('RGB')\n            \n        image.save(buffer, format=\"WEBP\", quality=80)\n        return buffer.getvalue()\n    except Exception as e:\n        print(f\"转换图片失败: {e}\")\n        return None\n\ndef upload_to_r2(image_data):\n    \"\"\"上传图片到 R2\"\"\"\n    if not image_data:\n        return None\n\n    client = init_r2_client()\n    \n    # 生成基础文件名\n    base_filename = f\"{uuid.uuid4()}.webp\"\n    filename = base_filename\n    \n    try:\n        # 检查文件是否已存在\n        attempt = 1\n        while True:\n            try:\n                # 尝试获取文件信息，如果文件存在会返回数据，不存在会抛出异常\n                client.head_object(\n                    Bucket=R2_CONFIG['bucket_name'],\n                    Key=f\"{OSS_CONFIG['prefix'].strip('/')}/{filename}\"\n                )\n                # 如果文件存在，修改文件名\n                name_without_ext = base_filename.rsplit('.', 1)[0]\n                filename = f\"{name_without_ext}_{attempt}.webp\"\n                attempt += 1\n                print(f\"文件名已存在，尝试重命名为: {filename}\")\n            except client.exceptions.ClientError as e:\n                # 如果是 404 错误，说明文件不存在，可以使用这个文件名\n                if e.response['Error']['Code'] == '404':\n                    break\n                raise e  # 其他错误则抛出\n                \n        # 上传文件\n        client.put_object(\n            Bucket=R2_CONFIG['bucket_name'],\n            Key=f\"{OSS_CONFIG['prefix'].strip('/')}/{filename}\",\n            Body=image_data,\n            ContentType='image/webp'\n        )\n        return filename\n    except Exception as e:\n        print(f\"上传失败: {e}\")\n        return None\n\ndef generate_markdown_link(filename):\n    \"\"\"生成 Markdown 图片链接\"\"\"\n    if not filename:\n        return None\n    \n    url = f\"https://{OSS_CONFIG['url']}{OSS_CONFIG['prefix']}/{filename}\"\n    return f\"![]({url})\"\n\ndef type_markdown_link(markdown_link):\n    \"\"\"模拟键盘输入 Markdown 链接\"\"\"\n    if not markdown_link:\n        return\n    \n    pyperclip.copy(markdown_link)\n    pyautogui.hotkey('ctrl', 'v')\n\ndef handle_upload():\n    \"\"\"处理图片上传的主函数\"\"\"\n    print(f\"\\n[{time.strftime('%Y-%m-%d %H:%M:%S')}] 收到粘贴请求\")\n    \n    print(\"正在检查剪贴板...\")\n    # 获取剪贴板图片\n    image = get_image_from_clipboard()\n    if not image:\n        print(\"❌ 剪贴板中没有图片\")\n        return\n    print(\"✅ 获取到剪贴板图片\")\n\n    # 转换为 webp\n    print(\"正在转换为 WebP 格式...\")\n    image_data = convert_to_webp(image)\n    if not image_data:\n        print(\"❌ 图片转换失败\")\n        return\n    print(f\"✅ 转换完成，大小: {len(image_data)/1024:.2f}KB\")\n\n    # 上传到 R2\n    print(\"正在上传到 R2...\")\n    filename = upload_to_r2(image_data)\n    if not filename:\n        print(\"❌ 上传失败\")\n        return\n    print(f\"✅ 上传成功，文件名: {filename}\")\n\n    # 生成并输入 Markdown 链接\n    markdown_link = generate_markdown_link(filename)\n    if markdown_link:\n        print(f\"生成的 URL: https://{OSS_CONFIG['url']}{OSS_CONFIG['prefix']}/{filename}\")\n        print(f\"模拟键入: {markdown_link}\")\n        type_markdown_link(markdown_link)\n        print(\"✅ 操作完成\")\n\ndef main():\n    \"\"\"主函数\"\"\"\n    print(\"=\" * 50)\n    print(\"R2 图片上传插件已启动\")\n    print(f\"当前配置:\")\n    print(f\"- OSS 域名: {OSS_CONFIG['url']}\")\n    print(f\"- 存储路径: {OSS_CONFIG['prefix']}\")\n    print(f\"- R2 存储桶: {R2_CONFIG['bucket_name']}\")\n    print(\"使用 Ctrl+Alt+V 上传剪贴板中的图片\")\n    print(\"=\" * 50)\n    \n    # 注册快捷键\n    keyboard.add_hotkey('ctrl+alt+v', handle_upload)\n    \n    # 保持程序运行\n    keyboard.wait()\n\nif __name__ == \"__main__\":\n    main() </code></pre>\n<p>例子1：另一个我的博客：<a href=\"https://www.onani.cn\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.onani.cn</a></p>\n<p>例子2：通过Cloudflare R2存储的图片：<a href=\"https://oss.onani.cn/fuwari-blog/img/47518d4403328a0fcb716f0e06fc7f608e6c65b7.webp\" target=\"_blank\" rel=\"noopener noreferrer\">https://oss.onani.cn/fuwari-blog/img/47518d4403328a0fcb716f0e06fc7f608e6c65b7.webp</a></p>\n<h3>3. IPFS</h3>\n<p>这种方式优点和缺点都及其明显。优点是完全无门槛，只需要找一个端点然后把你的图片上传到IPFS就行了，每次上传完后会返回给你一个URL，访问就能直接访问到你的图片。缺点是完全无法管理，由于IPFS的特殊性，无人PIN的文件会在之后慢慢消失，并且你也要考虑你现在正在使用的IPFS网关是否被GFW所阻拦。这里推荐一个 ipfs.crossbell.io 这个网关，上传端点是 /upload，带key file, value 源图片即可</p>\n<p>例子：<a href=\"https://ipfs.crossbell.io/ipfs/QmYdMcGvpfTvrab4cF1bctpNgPXzPv84FrN7tyxNfarwj6\" target=\"_blank\" rel=\"noopener noreferrer\">https://ipfs.crossbell.io/ipfs/QmYdMcGvpfTvrab4cF1bctpNgPXzPv84FrN7tyxNfarwj6</a></p>\n<p>注意，图中的 <a href=\"https://ipfs-relay.crossbell.io\" target=\"_blank\" rel=\"noopener noreferrer\">https://ipfs-relay.crossbell.io</a> 仅能用于上传（谷歌云CDN），而展示图片只能使用 <a href=\"https://ipfs.crossbell.io\" target=\"_blank\" rel=\"noopener noreferrer\">https://ipfs.crossbell.io</a> （ovh CDN）</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://ai.onani.cn/media/posts/18/Snipaste_2025-02-21_04-52-07.webp\" alt=\"\" width=\"1945\" height=\"1212\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_04-52-07-xs.webp 640w ,https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_04-52-07-sm.webp 768w ,https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_04-52-07-md.webp 1024w ,https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_04-52-07-lg.webp 1366w ,https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_04-52-07-xl.webp 1600w ,https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_04-52-07-2xl.webp 1920w\"></figure>\n<h3>最后，图片大小也要进行优化</h3>\n<p>无论你选择哪一个存图方式，都需要对图片大小进行额外的优化。考虑到大部分图片都是来自于屏幕截图，我强烈推荐使用 <a href=\"https://zh.snipaste.com/\">Snipaste - 截图 + 贴图</a> 。并且在设置中将保存的图片格式改为<strong>webp</strong>，每张图片仅200KB，相较于png的2MB小了不少</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://ai.onani.cn/media/posts/18/Snipaste_2025-02-21_05-03-24.webp\" alt=\"\" width=\"616\" height=\"815\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_05-03-24-xs.webp 640w ,https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_05-03-24-sm.webp 768w ,https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_05-03-24-md.webp 1024w ,https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_05-03-24-lg.webp 1366w ,https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_05-03-24-xl.webp 1600w ,https://ai.onani.cn/media/posts/18/responsive/Snipaste_2025-02-21_05-03-24-2xl.webp 1920w\"></figure>",
            "author": {
                "name": "AcoFork"
            },
            "tags": [
                   "开发"
            ],
            "date_published": "2025-02-21T04:36:36+08:00",
            "date_modified": "2025-02-21T05:04:01+08:00"
        },
        {
            "id": "https://ai.onani.cn/ipfs-pixiv.html",
            "url": "https://ai.onani.cn/ipfs-pixiv.html",
            "title": "使用IPFS搭建Pixiv镜像站",
            "summary": "基本思路&amp;原理 IPFS是一个去中心化的存储托管平台，并且支持匿名上传，上传后的文件可以直接通过HTTP网关直接读取，我们可以将它作为Pixiv镜像站的图床。由于中国大陆墙了&hellip;",
            "content_html": "<h1>基本思路&amp;原理</h1>\n<p>IPFS是一个去中心化的存储托管平台，并且支持匿名上传，上传后的文件可以直接通过HTTP网关直接读取，我们可以将它作为Pixiv镜像站的图床。由于中国大陆墙了 ipfs.io 这个主网关，我们可以使用其他网关，如：ipfs.crossbell.io 。本次介绍的项目也会使用这个网关来进行上传/读取Pixiv的图片</p>\n<p>既然图床已经就绪，接下来就是制作一个美观的展示界面，这里我使用 <a href=\"https://www.mdui.org/zh-cn/\">MDUI</a> 。这是一个简洁优雅的UI组件库，我们不需要自己重新编写CSS样式，就可以直接制作出风格统一的网页。无需担心上手难度，你可以直接使用 <a href=\"https://github.com/features/copilot\">GitHub Copilot</a> ，让AI帮你完成一切工作</p>\n<p>那么最后，我们需要编写一个自动脚本定时抓取Pixiv源站的排行榜图片并将其上传到IPFS，为了完全云托管，我们将会使用Github Action，项目已经写好，就在 <a href=\"https://github.com/afoim/IPFS-PixivImg\">afoim/IPFS-PixivImg: 一个基于ipfs的Pixiv图床项目</a> </p>\n<h1>效果展示&amp;成品网站链接</h1>\n<p><a href=\"https://ipfs-px.onani.cn/\">Pixiv 排行榜</a></p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://ai.onani.cn/media/posts/16/Snipaste_2025-02-18_06-32-46.webp\" alt=\"\" width=\"2549\" height=\"1373\" sizes=\"(max-width: 1920px) 100vw, 1920px\" srcset=\"https://ai.onani.cn/media/posts/16/responsive/Snipaste_2025-02-18_06-32-46-xs.webp 640w ,https://ai.onani.cn/media/posts/16/responsive/Snipaste_2025-02-18_06-32-46-sm.webp 768w ,https://ai.onani.cn/media/posts/16/responsive/Snipaste_2025-02-18_06-32-46-md.webp 1024w ,https://ai.onani.cn/media/posts/16/responsive/Snipaste_2025-02-18_06-32-46-lg.webp 1366w ,https://ai.onani.cn/media/posts/16/responsive/Snipaste_2025-02-18_06-32-46-xl.webp 1600w ,https://ai.onani.cn/media/posts/16/responsive/Snipaste_2025-02-18_06-32-46-2xl.webp 1920w\"></figure>",
            "image": "https://ai.onani.cn/media/posts/16/Snipaste_2025-02-18_06-32-46-2.webp",
            "author": {
                "name": "AcoFork"
            },
            "tags": [
                   "开发"
            ],
            "date_published": "2025-02-18T06:17:08+08:00",
            "date_modified": "2025-02-18T09:21:25+08:00"
        }
    ]
}
